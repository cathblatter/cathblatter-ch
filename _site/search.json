[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cath Blatter",
    "section": "",
    "text": "Hi 👋!\nI’m a registered-nurse-turned-data-lover and PhD student at a Swiss university. I like to build and hack code to make research processes faster, less ambiguous, more reproducible and aim to provide meaningful data insights and outputs for use in clinical settings.\nI have experience in data preparation and analysis in health services research (i.e., survey studies and routinely collected data from electronic health records). My latest work includes development and implementation of analytic workflows for teams with a non-technical background, including but not limited to:\n\nmultilingual reporting of study results (descriptive & bench marked)\n\ndevelopment of several internally-used R packages\n\ndata visualization for communication with research and practice stakeholders\n\ninstruction, guidance and consultancy on programming and data management"
  },
  {
    "objectID": "posts/2019/2019-11-28-Using_purrr_map.html",
    "href": "posts/2019/2019-11-28-Using_purrr_map.html",
    "title": "Using purrr::map() to identify available datasets in a list",
    "section": "",
    "text": "What happened?\nRecently I wanted to explore plotting R for the first time and discovered the ggswissmaps-package.\nI’m new to the structure of geospatial data so I read the introductory vignette and followed the examples.\n\nExamples from the ggswissmaps-package\n\n#install.packages(\"ggswissmaps\")\n\nsuppressPackageStartupMessages(library(ggswissmaps))\nsuppressPackageStartupMessages(library(tidyverse))\n\n# Data frame with the coordinates of all swiss districts\nd <- shp_df[[\"g1b15\"]]\n\n# Look at the structure of the data frame\nglimpse(d)\n\nRows: 19,502\nColumns: 21\n$ long    <int> 679207, 680062, 679981, 680365, 680281, 680479, 680717, 681021…\n$ lat     <int> 245176, 244294, 244051, 243411, 241866, 241584, 240695, 240306…\n$ order   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,…\n$ hole    <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,…\n$ piece   <fct> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ group   <fct> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.…\n$ id      <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0…\n$ BZNR    <int> 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 10…\n$ KTNR    <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ GRNR    <int> 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,…\n$ AREA_HA <int> 11303, 11303, 11303, 11303, 11303, 11303, 11303, 11303, 11303,…\n$ X_MIN   <int> 671862, 671862, 671862, 671862, 671862, 671862, 671862, 671862…\n$ X_MAX   <int> 686462, 686462, 686462, 686462, 686462, 686462, 686462, 686462…\n$ Y_MIN   <int> 229137, 229137, 229137, 229137, 229137, 229137, 229137, 229137…\n$ Y_MAX   <int> 245396, 245396, 245396, 245396, 245396, 245396, 245396, 245396…\n$ X_CNTR  <int> 678300, 678300, 678300, 678300, 678300, 678300, 678300, 678300…\n$ Y_CNTR  <int> 235900, 235900, 235900, 235900, 235900, 235900, 235900, 235900…\n$ Z_MIN   <int> 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 38…\n$ Z_MAX   <int> 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 91…\n$ Z_AVG   <int> 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 56…\n$ Z_MED   <int> 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 55…\n\n# The cantons are identified by the KTNR column\n# Extract from this data the districts of two cantons (18 = Graubünden, 21 = Ticino)\n\ntwo_cantons <- d %>% filter(KTNR  %in%  c(18, 21))\n\n# And draw the map\nmaps2_(two_cantons)\n\n\n\n\nThis worked quite fine - but I was more interested in plotting by language region, so I did the following:\n\n# add an aditional variable \"region\"\nd %>% \n  mutate(region = case_when(KTNR == 21 ~ \"Ticino\",\n                                 KTNR  %in% c(22, 23, 24, 25, 26) ~ \"Romandie\",\n                                 TRUE ~ \"Deutschschweiz\")) -> d\n\n# draw a ggplot \nggplot(d, aes(x = long, y = lat, group = group)) +\n  geom_polygon(aes(fill = factor(region)), color = \"black\") +\n  scale_fill_manual(name = \"Region\",\n                   values = c(\"Ticino\" = \"grey90\",\n                              \"Romandie\" = \"#b2df8a\",\n                              \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal()\n\n\n\n\n\n\nTroubleshooting\nWhat is the problem with this plot (aside from the ugly black color of the boundaries)? The boundaries correspond to district, not cantonal level (what I wanted). As the variable KTNR identifies the cantons, I did the following:\n\n# draw a ggplot and changed to aes(....group = KTNR)\nggplot(d, aes(x = long, y = lat, group = KTNR)) +\n  geom_polygon(aes(fill = factor(region)), color = \"black\") +\n  scale_fill_manual(name = \"Region\",\n                   values = c(\"Ticino\" = \"grey90\",\n                              \"Romandie\" = \"#b2df8a\",\n                              \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal()\n\n\n\n\n…It got even worse…\nI did not understand why at first. After a brief online exchange in the Rladies-Slack (sidenote: fantastic place to learn! 😎), I realized that my problem is with the data: aes(x = long, y = lat) in my dataframe correspond to district level not cantonal level. Unfortunately, the link on the website of the Federal Office of Statistics didn’t work either1, so what to do else?\nLook at the data structure:\n\n# a list containing 8 elements (dataframes)\n# which each contain lon/lat on different levels\nclass(shp_df)\n\n[1] \"list\"\n\n# very long output, not shown here\n#str(shp_df)\n\nI now knew that I could use the plot from above and check each element of the list - either by hand (corresponding to seven times copy/paste) or with purrr::map()!\n\n\nSolution\n\n# create a function to map over each element of the list to\n# identify if one is on cantonal-level\nmy_plot <- function(data){\n  \n  ggplot2::ggplot(data = data, ggplot2::aes(x = long, y = lat, group = group)) +\n    ggplot2::geom_polygon() +\n    ggplot2::theme_void() +\n    coord_equal()\n  \n}\n\nThen do the magic (1 simple line of code will give me 8 plots!):\n\n# map it over the list\npurrr::map(ggswissmaps::shp_df, ~my_plot(.x))\n\n$g1b15\n\n\n\n\n\n\n$g1g15_encl\n\n\n\n\n\n\n$g1g15_li\n\n\n\n\n\n\n$g1g15\n\n\n\n\n\n\n$g1k15\n\n\n\n\n\n\n$g1l15\n\n\n\n\n\n\n$g1r15\n\n\n\n\n\n\n$g1s15\n\n\n\n\n\nFrom the plots above I now know which dataframe to use:\n\n# solution: the second last element of the list is what I need\ncant_level <- \n  ggswissmaps::shp_df$g1k15 %>% \n      mutate(region = case_when(KTNR == 21 ~ \"Ticino\",\n                                KTNR  %in% c(22, 23, 24, 25, 26) ~ \"Romandie\",\n                                TRUE ~ \"Deutschschweiz\"))\n\n# draw the prettier graph\nggplot(cant_level, aes(x = long, y = lat, group = group)) +\n  geom_polygon(aes(fill = factor(region))) +\n  scale_fill_manual(name = \"Region\",\n                   values = c(\"Ticino\" = \"grey90\",\n                              \"Romandie\" = \"#b2df8a\",\n                              \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal()\n\n\n\n\nThe output is what I wanted - altough we could improve it, as the lakes (which are left out in the district-level data) are not shown here…\nEdit:\nthanks to the ggswissmaps-maintainer gibo’s help, the maps look now much prettier:\n\nggplot(cant_level, aes(x = long, y = lat, group = group)) +\n  geom_polygon(aes(fill = factor(region)), color = \"white\", size = 0.1) +\n  scale_fill_manual(name = \"Region\",\n                    values = c(\"Ticino\" = \"grey90\",\n                               \"Romandie\" = \"#b2df8a\",\n                               \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal() + # add a layer for the lakes\n  geom_polygon(aes(x = long, y = lat, group = group), \n               data = shp_df[[\"g1s15\"]], fill = NA, alpha = .5, color = \"#0529B3\", size = .1, lty = \"solid\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\nFootnotes\n\n\nIn the meantime, the package maintainer provided me with the working links: https://www.bfs.admin.ch/bfs/fr/home/services/geostat/geodonnees-statistique-federale.html.↩︎"
  },
  {
    "objectID": "listings.html",
    "href": "listings.html",
    "title": "Catherine Blatter",
    "section": "",
    "text": "Different approaches to rename variables\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 24, 2022\n\n\nCath Blatter\n\n\n\n\n\n\n  \n\n\n\n\nAn (ever growing) list of random things in R\n\n\n\n\n\n\n\n\n\n\n\n\nJan 27, 2022\n\n\nCath Blatter\n\n\n\n\n\n\n  \n\n\n\n\nInstalling & using multiple R versions aside\n\n\n\n\n\n\n\n\n\n\n\n\nMar 6, 2021\n\n\nCath Blatter\n\n\n\n\n\n\n  \n\n\n\n\nUsing tidyr::pivot_longer() and regex for data wrangling\n\n\n\n\n\n\n\n\n\n\n\n\nMar 16, 2020\n\n\nCath Blatter\n\n\n\n\n\n\n  \n\n\n\n\nUsing purrr::map() to identify available datasets in a list\n\n\n\n\n\n\n\npurrr\n\n\n\n\n\n\n\n\n\n\n\nNov 28, 2019\n\n\nCath Blatter\n\n\n\n\n\n\n  \n\n\n\n\nGetting PubMed metadata with RISmed directly into RStudio\n\n\n\n\n\n\n\nRISmed\n\n\n\n\n\n\n\n\n\n\n\nApr 29, 2019\n\n\nCatherine Blatter\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2020/2020-03-16-using-pivot-longer-and-regex-for-data-wrangling.html",
    "href": "posts/2020/2020-03-16-using-pivot-longer-and-regex-for-data-wrangling.html",
    "title": "Using tidyr::pivot_longer() and regex for data wrangling",
    "section": "",
    "text": "TL;DR\nThis code shows you how you can effectively wrangle your dataframe from wide to long using tidyr::pivot_longer() combined with regular expressions for properly naming the variables.\n\n\nYour data is… not in the right format!\nYou have a wide dataset of patient data, each patient identified through ID. They have been hospitalised multiple times, each place of hospitalisation and outcome listed in its own variable. Place and Outcome of a hospitalization are linked with the same suffix number, e.g. _2_2:\n\n# load packages\nsuppressPackageStartupMessages(library(tidyverse))\n\n# create sample data\npatient_data <- \ntibble::tribble(~ID, ~Hosp_Place_1, ~Hosp_Outcome_1, ~Hosp_Place_2_2, \n                ~Hosp_Outcome_2_2, ~Hosp_Place_2_3, ~Hosp_Outcome_2_3, \n                1, \"London\", \"Alive\", \"Paris\", \"alive\", \"Rome\", \"dead\",\n                2, \"Paris\", \"alive\", \"Rome\", \"alive\", \"London\", \"alive\",\n                3, \"Berne\", \"dead\", NA_character_, NA_character_, NA_character_, NA_character_) \n\n# look at data\npatient_data\n\n# A tibble: 3 × 7\n     ID Hosp_Place_1 Hosp_Outcome_1 Hosp_Place_2_2 Hosp_Outcom…¹ Hosp_…² Hosp_…³\n  <dbl> <chr>        <chr>          <chr>          <chr>         <chr>   <chr>  \n1     1 London       Alive          Paris          alive         Rome    dead   \n2     2 Paris        alive          Rome           alive         London  alive  \n3     3 Berne        dead           <NA>           <NA>          <NA>    <NA>   \n# … with abbreviated variable names ¹​Hosp_Outcome_2_2, ²​Hosp_Place_2_3,\n#   ³​Hosp_Outcome_2_3\n\n\nPatient No. 3 died in his first hospitatisation, so the following variables are listed NA.\nFor some analysis, this data structure would work ok, but for your specific questions you need to switch the unit of analysis to “hospitalisation” instead of “patient”. In other words, you’d like to switch the data from wide to long.\nThanks to the tidyverse’s initiative of making clear function names, it might be obvious, that tidyr::pivot_longer() should do what you want.\n\n\nFamiliarize yourself with the function - What to do with tidyr::pivot_longer()?\nThe first step is to initially think about, what the outcome should look like and what input-arguments the function takes, so let’s do this:\n\n# tidyr::pivot_long() and its arguments\ntidyr::pivot_longer(data, \n                    cols, \n                    names_to = \"name\", \n                    names_prefix = NULL, \n                    names_sep = NULL, \n                    names_pattern = NULL,\n                    names_ptypes = list(),\n                    names_repair = \"check_unique\",\n                    values_to = \"value\",\n                    values_drop_na = FALSE,\n                    values_ptypes = list())\n\nAs you can see, only data and cols are effectively needed, so let’s try that. As I want to exclude the Patient-ID from pivoting, I remove this line from pivoting:\n\n# as with all the tidyverse functions you can easily pipe-in the data as \n# the first argument\n\n# '-ID' means, that all variables are used other than ID\npatient_data %>% \n  pivot_longer(cols = -ID)\n\n# A tibble: 18 × 3\n      ID name             value \n   <dbl> <chr>            <chr> \n 1     1 Hosp_Place_1     London\n 2     1 Hosp_Outcome_1   Alive \n 3     1 Hosp_Place_2_2   Paris \n 4     1 Hosp_Outcome_2_2 alive \n 5     1 Hosp_Place_2_3   Rome  \n 6     1 Hosp_Outcome_2_3 dead  \n 7     2 Hosp_Place_1     Paris \n 8     2 Hosp_Outcome_1   alive \n 9     2 Hosp_Place_2_2   Rome  \n10     2 Hosp_Outcome_2_2 alive \n11     2 Hosp_Place_2_3   London\n12     2 Hosp_Outcome_2_3 alive \n13     3 Hosp_Place_1     Berne \n14     3 Hosp_Outcome_1   dead  \n15     3 Hosp_Place_2_2   <NA>  \n16     3 Hosp_Outcome_2_2 <NA>  \n17     3 Hosp_Place_2_3   <NA>  \n18     3 Hosp_Outcome_2_3 <NA>  \n\n# I could have put the following instead, meaning selecting the variables I want\n# but it was generally shorter to drop just the ID\n# patient_data %>%\n#   pivot_longer(cols = Hosp_Place_1:Hosp_Outcome_2_3)\n\nSomething clearly happened, but name and value are not exactly what we want here.\nThe colnames “name” and “value” are actually coming from the default arguments.\nWhat is now the next step?\n\n\nMental image of desired outcome - How should my dataframe look like?\nMy desired output is a dataframe with the colum names ID, Hosp_Place and Hosp_Outcome. Additionally, I want a variable - lets call it hosp_sequence - that captures the number of the hospitalisation (you remember the suffix of the original variable names).\ntidyr::pivot_longer()’s names_to =-arguments states in the help-page:\nCan be a character vector, creating multiple columns, if names_sep or names_pattern is provided.\nIf you can detect any patterns in the column names, its possible to use them for the column naming. If we look at Hosp_Place_1 and Hosp_Outcome_1 we can clearly see a pattern: The information I want as name is Hosp_Place and Hosp_Outcome and the number followed should be put in variable called hosp_sequence.\nThis translates to something like (Hosp_Place)_(1) where the parts in brackets correspond to the inputs given in names_to =. With the .value-argument, I can easily take over the string as it is.\nI actually found this very confusing (honestly - still do…) and I had great help for defining the regular expression from R4DS1.\nFinally, this is the code we need:\n\n# this code should do the trick\npatient_data %>% \n  pivot_longer(cols = -ID, \n               names_to = c(\".value\", \"hosp_sequence\"),\n               names_pattern = '(^[A-z]+_[A-z]+)_([0-9].*)')\n\n# A tibble: 9 × 4\n     ID hosp_sequence Hosp_Place Hosp_Outcome\n  <dbl> <chr>         <chr>      <chr>       \n1     1 1             London     Alive       \n2     1 2_2           Paris      alive       \n3     1 2_3           Rome       dead        \n4     2 1             Paris      alive       \n5     2 2_2           Rome       alive       \n6     2 2_3           London     alive       \n7     3 1             Berne      dead        \n8     3 2_2           <NA>       <NA>        \n9     3 2_3           <NA>       <NA>        \n\n\nWait, what is happening with rows 8 and 9? This is my deceased Patient No. 3 an those are not hospitalisations anymore - how do I drop those rows?\n\n# you can either use dplyr::drop_na() or specify the built-in argument to TRUE\npatient_data %>% \n  pivot_longer(cols = -ID, \n               names_to = c(\".value\", \"hosp_sequence\"),\n               names_pattern = '(^[A-z]+_[A-z]+)_([0-9].*)', \n               values_drop_na = TRUE)\n\n# A tibble: 7 × 4\n     ID hosp_sequence Hosp_Place Hosp_Outcome\n  <dbl> <chr>         <chr>      <chr>       \n1     1 1             London     Alive       \n2     1 2_2           Paris      alive       \n3     1 2_3           Rome       dead        \n4     2 1             Paris      alive       \n5     2 2_2           Rome       alive       \n6     2 2_3           London     alive       \n7     3 1             Berne      dead        \n\n\n\n\nComment\nI wrote this blogpost after after solving exactly this issue with a real dataset for a colleague.\nMy work as a research programmer allows me to dive into data wrangling problems on a regular basis. As I learned most of my R skills from other blogposts from the fantastic R community, I started to write up some of the problems I encountered for others. I also use my previous blogposts sometimes, when I have to dig up old code…\nAny comments from your side? Let me know!\n\n\n\n\n\nFootnotes\n\n\nhttps://rfordatascience.slack.com/archives/C8K09CDNZ/p1584129595187200 If you are not already on this slack - sign up for it! Its just so great, low key help and great learning opportunities to just dive through the topics. ↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Catherine Blatter",
    "section": "",
    "text": "since 2020: PhD student\nUniversity of Basel\n2019: MSc Nursing\nUniversity of Basel\n2012: Registered Nurse (RN)"
  },
  {
    "objectID": "about.html#work-experience",
    "href": "about.html#work-experience",
    "title": "Catherine Blatter",
    "section": "Work experience",
    "text": "Work experience\n\nsince 2020: Teaching assistant\nsince 2016: Research assistant\nUniversity of Basel\n2012-2016: RN in several Swiss acute care hospitals"
  }
]