{
  "hash": "6db528cd728c2fa62b41caf0aac2a094",
  "result": {
    "markdown": "---\ntitle: 'Using purrr::map() to identify available datasets in a list'\nauthor: \n  - name: Cath Blatter\ndate: '2019-11-28'\ncategories: [purrr]\nimage: plot-fail.png\nformat: \n  html:\n    toc: true\n---\n\n\n# What happened? \n\nRecently I wanted to explore plotting R for the first time and discovered the \n[ggswissmaps-package](https://cran.r-project.org/web/packages/ggswissmaps/ggswissmaps.pdf).\n\nI'm new to the structure of geospatial data so I read the introductory vignette and followed the examples. \n\n### Examples from the ggswissmaps-package\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"ggswissmaps\")\n\nsuppressPackageStartupMessages(library(ggswissmaps))\nsuppressPackageStartupMessages(library(tidyverse))\n\n# Data frame with the coordinates of all swiss districts\nd <- shp_df[[\"g1b15\"]]\n\n# Look at the structure of the data frame\nglimpse(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 19,502\nColumns: 21\n$ long    <int> 679207, 680062, 679981, 680365, 680281, 680479, 680717, 681021â€¦\n$ lat     <int> 245176, 244294, 244051, 243411, 241866, 241584, 240695, 240306â€¦\n$ order   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,â€¦\n$ hole    <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,â€¦\n$ piece   <fct> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,â€¦\n$ group   <fct> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.â€¦\n$ id      <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0â€¦\n$ BZNR    <int> 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 10â€¦\n$ KTNR    <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,â€¦\n$ GRNR    <int> 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,â€¦\n$ AREA_HA <int> 11303, 11303, 11303, 11303, 11303, 11303, 11303, 11303, 11303,â€¦\n$ X_MIN   <int> 671862, 671862, 671862, 671862, 671862, 671862, 671862, 671862â€¦\n$ X_MAX   <int> 686462, 686462, 686462, 686462, 686462, 686462, 686462, 686462â€¦\n$ Y_MIN   <int> 229137, 229137, 229137, 229137, 229137, 229137, 229137, 229137â€¦\n$ Y_MAX   <int> 245396, 245396, 245396, 245396, 245396, 245396, 245396, 245396â€¦\n$ X_CNTR  <int> 678300, 678300, 678300, 678300, 678300, 678300, 678300, 678300â€¦\n$ Y_CNTR  <int> 235900, 235900, 235900, 235900, 235900, 235900, 235900, 235900â€¦\n$ Z_MIN   <int> 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 38â€¦\n$ Z_MAX   <int> 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 91â€¦\n$ Z_AVG   <int> 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 56â€¦\n$ Z_MED   <int> 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 55â€¦\n```\n:::\n\n```{.r .cell-code}\n# The cantons are identified by the KTNR column\n# Extract from this data the districts of two cantons (18 = GraubÃ¼nden, 21 = Ticino)\n\ntwo_cantons <- d %>% filter(KTNR  %in%  c(18, 21))\n\n# And draw the map\nmaps2_(two_cantons)\n```\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\nThis worked quite fine - but I was more interested in plotting by language region, so I did \nthe following: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add an aditional variable \"region\"\nd %>% \n  mutate(region = case_when(KTNR == 21 ~ \"Ticino\",\n                                 KTNR  %in% c(22, 23, 24, 25, 26) ~ \"Romandie\",\n                                 TRUE ~ \"Deutschschweiz\")) -> d\n\n# draw a ggplot \nggplot(d, aes(x = long, y = lat, group = group)) +\n  geom_polygon(aes(fill = factor(region)), color = \"black\") +\n  scale_fill_manual(name = \"Region\",\n                   values = c(\"Ticino\" = \"grey90\",\n                              \"Romandie\" = \"#b2df8a\",\n                              \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n### Troubleshooting\n\nWhat is the problem with this plot (aside from the ugly black color of the boundaries)? The boundaries correspond to district, not cantonal level (what I wanted). As the variable `KTNR` identifies the cantons, I did the following: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# draw a ggplot and changed to aes(....group = KTNR)\nggplot(d, aes(x = long, y = lat, group = KTNR)) +\n  geom_polygon(aes(fill = factor(region)), color = \"black\") +\n  scale_fill_manual(name = \"Region\",\n                   values = c(\"Ticino\" = \"grey90\",\n                              \"Romandie\" = \"#b2df8a\",\n                              \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n...It got even worse...  \n\nI did not understand why at first. After a brief online exchange in the Rladies-Slack (sidenote: fantastic place to learn! ðŸ˜Ž), I realized that my problem is with the data: `aes(x = long, y = lat)` in my dataframe correspond to district level not cantonal level. Unfortunately, the link on the website of the Federal Office of Statistics didn't work either^[In the meantime, the package maintainer provided me with the working links:\nhttps://www.bfs.admin.ch/bfs/fr/home/services/geostat/geodonnees-statistique-federale.html.], so what to do else?  \n\nLook at the data structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a list containing 8 elements (dataframes)\n# which each contain lon/lat on different levels\nclass(shp_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\n# very long output, not shown here\n#str(shp_df)\n```\n:::\n\n\nI now knew that I could use the plot from above and check each element of the list - \neither by hand (corresponding to seven times copy/paste) or with `purrr::map()`!\n\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a function to map over each element of the list to\n# identify if one is on cantonal-level\nmy_plot <- function(data){\n  \n  ggplot2::ggplot(data = data, ggplot2::aes(x = long, y = lat, group = group)) +\n    ggplot2::geom_polygon() +\n    ggplot2::theme_void() +\n    coord_equal()\n  \n}\n```\n:::\n\n\nThen do the magic (1 simple line of code will give me 8 plots!): \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# map it over the list\npurrr::map(ggswissmaps::shp_df, ~my_plot(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$g1b15\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1g15_encl\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1g15_li\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-3.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1g15\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-4.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1k15\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-5.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1l15\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-6.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1r15\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-7.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n$g1s15\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-6-8.png){width=672}\n:::\n:::\n\n\n\nFrom the plots above I now know which dataframe to use: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# solution: the second last element of the list is what I need\ncant_level <- \n  ggswissmaps::shp_df$g1k15 %>% \n      mutate(region = case_when(KTNR == 21 ~ \"Ticino\",\n                                KTNR  %in% c(22, 23, 24, 25, 26) ~ \"Romandie\",\n                                TRUE ~ \"Deutschschweiz\"))\n\n# draw the prettier graph\nggplot(cant_level, aes(x = long, y = lat, group = group)) +\n  geom_polygon(aes(fill = factor(region))) +\n  scale_fill_manual(name = \"Region\",\n                   values = c(\"Ticino\" = \"grey90\",\n                              \"Romandie\" = \"#b2df8a\",\n                              \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nThe output is what I wanted - altough we could improve it, as the lakes (which are left out in the district-level data) are not shown here...  \n\n*Edit:*  \n\nthanks to the `ggswissmaps`-maintainer [gibo's](https://github.com/gibonet) help, the maps look now much prettier:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(cant_level, aes(x = long, y = lat, group = group)) +\n  geom_polygon(aes(fill = factor(region)), color = \"white\", size = 0.1) +\n  scale_fill_manual(name = \"Region\",\n                    values = c(\"Ticino\" = \"grey90\",\n                               \"Romandie\" = \"#b2df8a\",\n                               \"Deutschschweiz\" = \"#a6cee3\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  coord_equal() + # add a layer for the lakes\n  geom_polygon(aes(x = long, y = lat, group = group), \n               data = shp_df[[\"g1s15\"]], fill = NA, alpha = .5, color = \"#0529B3\", size = .1, lty = \"solid\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nâ„¹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](2019-11-28-Using_purrr_map_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "2019-11-28-Using_purrr_map_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}