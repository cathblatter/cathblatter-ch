{
  "hash": "f570dad3c7fadcde4775d74bd1cdfec9",
  "result": {
    "markdown": "---\ntitle: Different approaches to rename variables \nauthor: Cath Blatter\ndate: '2022-02-24'\nimage: names.png\n---\n\n\n## Renaming individual columns\n\nThis was usually a rather small post with snippets but turned out to be \nmuch more interesting...\n\n**Loading the necessary package**\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n**Sample dataframe**\n\nCreating a sample dataframe: the function `tribble()` lets you construct \nrowwise-tibbles (thus the R in `tribble()`). This is closer to the idea of \ndata in a spreadsheet than the mirrored version with `tibble()` or `data.frame()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble::tribble(\n  ~id, ~pesnwi_leadership, ~pesnwi_sra, ~bernca_adl, ~bernca_docu,\n  1, 2.3, 2.1, 1.8, 1.4,\n  2, 2.0, 3, 2.1, 0.9,\n  3, 3.1, 3.5, 3.9, 3\n)\n```\n:::\n\n\nThis is the equivalent code for the 'mirrored' version: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- \n  data.frame(\n                   id = c(1, 2, 3),\n    pesnwi_leadership = c(2.3, 2, 3.1),\n           pesnwi_sra = c(2.1, 3, 3.5),\n           bernca_adl = c(1.8, 2.1, 3.9),\n          bernca_docu = c(1.4, 0.9, 3)\n  )\n```\n:::\n\n\nFinally, this is how the dataframe looks like: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n     id pesnwi_leadership pesnwi_sra bernca_adl bernca_docu\n  <dbl>             <dbl>      <dbl>      <dbl>       <dbl>\n1     1               2.3        2.1        1.8         1.4\n2     2               2          3          2.1         0.9\n3     3               3.1        3.5        3.9         3  \n```\n:::\n:::\n\n\n\n### Manual renaming with `dplyr::rename()`\n\nManual renaming following the idea of newname = oldname.\nThis is the approach you need to take for manual replacement of \ncolumn-names (see an equivalent base-R code below). You can rename more than\nthree variables like this, just add further combinations of newname = oldname...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rename(\n    pesnwi_ls = pesnwi_leadership,\n    ration_adl = bernca_adl,\n    ration_docu = bernca_docu\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n     id pesnwi_ls pesnwi_sra ration_adl ration_docu\n  <dbl>     <dbl>      <dbl>      <dbl>       <dbl>\n1     1       2.3        2.1        1.8         1.4\n2     2       2          3          2.1         0.9\n3     3       3.1        3.5        3.9         3  \n```\n:::\n:::\n\n\n### Manual renaming with `base-R`\n\nOf course its also possible to rename the columns with other approaches, e.g. : \n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df)[names(df)==\"pesnwi_leadership\"] <- \"pesnwi_ls\"\n```\n:::\n\n\n## Renaming multiple columns at once\n\n### Renaming based on text-patterns with `dplyr::rename_with()`\n\nIt's possible to rename multiple column-names based on matching text-patterns \n(regular expression). This is great if you need to rename multiple variables with\nthe same pattern, but it only works if you can find such a pattern. If you're in \ndoubt which option to choose its probably safer to do the manual method above...\n\nFor the example dataframe, say we want to replace the prefix \"bernca\" (the name of \nan instrument to measure rationed nursing care ^[Schubert et al., 2007, https://doi.org/10.1097/01.nnr.0000299853.52429.62]) \nby the more general term \"ration\". This is possible with the following code: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rename_with(\n    .fn = ~ stringr::str_replace(., pattern = \"bernca\", replacement = \"ration\"),\n    .cols = everything()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n     id pesnwi_leadership pesnwi_sra ration_adl ration_docu\n  <dbl>             <dbl>      <dbl>      <dbl>       <dbl>\n1     1               2.3        2.1        1.8         1.4\n2     2               2          3          2.1         0.9\n3     3               3.1        3.5        3.9         3  \n```\n:::\n:::\n\n\nBy default, all columns get considered, but we could limit this or manually \ndefine the columns with `c(bernca_adl, bernca_docu)`. Note that I used the {stringr} package\nfor replacing the pattern 'bernca' with 'ration'. \n\n\n## Renaming based on names defined in an external document (e.g. xlsx)\n\nImagine the following situation: a survey study with three timepoints was conducted\nover a timespan of 2 years: T0 as baseline, T1 = T0+12months and T2 = T0+24months.  \nSome of the questions were only asked at baseline, some across all timepoints and\nselected variables only in T1 and T2. For several reasons (a.k.a. real-life data collection) \nthis led to situations, where a variable named X12 in T0, did in fact not correspond to the variable named X12 in T1 and so on. \n\nIn total there were > 250 variables to rename and the person defining the new variables did not work with R. Thus, the solution was to store the information in an external spreadsheet and then write code to import this spreadsheet and rename based on it. But how?\n\nA spreadsheet was created in excel that essentially \nheld information on the variable names of a specific questions across all time points. \nAdditionally, the first column 'global' defines the new variable name that will be used across all \ndatasets once the renaming took place. Below is a small example of how the excel-file \nlooked like:\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> global </th>\n   <th style=\"text-align:left;\"> T0 </th>\n   <th style=\"text-align:left;\"> T1 </th>\n   <th style=\"text-align:left;\"> T2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> ID </td>\n   <td style=\"text-align:left;\"> ID </td>\n   <td style=\"text-align:left;\"> ID </td>\n   <td style=\"text-align:left;\"> ID </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> X1 </td>\n   <td style=\"text-align:left;\"> X1 </td>\n   <td style=\"text-align:left;\"> X3 </td>\n   <td style=\"text-align:left;\"> X2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> X2 </td>\n   <td style=\"text-align:left;\"> X4 </td>\n   <td style=\"text-align:left;\"> X10 </td>\n   <td style=\"text-align:left;\"> X11 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> X3 </td>\n   <td style=\"text-align:left;\">  </td>\n   <td style=\"text-align:left;\"> X2 </td>\n   <td style=\"text-align:left;\"> X12 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n### Creating sample datasets \n\nBelow I created some sample datasets to mimic T0, T1 and T2 and the information \nfrom the spreadsheet: \n\n**For the data from the surveys T0, T1, T2**\n\n\n::: {.cell}\n\n```{.r .cell-code}\norig_t0 <- tibble::tribble(\n  ~ID, ~X1, ~X4,\n  \"A\", \"m\", 1,\n  \"B\", \"x\", 2\n)\n\norig_t1 <-  tibble::tribble(\n  ~ID, ~X3, ~X10, ~X2,\n  \"AAA\", \"f\", 1, 44,\n  \"BBB\", \"x\", 2, 56,\n)\n\norig_t2 <-  tibble::tribble(\n  ~ID, ~X2, ~X11, ~X12,\n  \"FFF\", \"f\", 2, 53,\n  \"BGG\", \"f\", 1, 23,\n)\n```\n:::\n\n\n**Information from the spreadsheet**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname_tbl <- tibble::tribble(\n  ~global, ~T0, ~T1, ~T2,\n  \"ID\", \"ID\", \"ID\", \"ID\",\n  \"X1\", \"X1\", \"X3\", \"X2\",\n  \"X2\", \"X4\", \"X10\", \"X11\",\n  \"X3\", NA_character_, \"X2\", \"X12\"\n)\n```\n:::\n\n\n\n### Using a named vector to rename dataframes\n\n*check also this tweet by @PipingHotData: https://twitter.com/PipingHotData/status/1497014703473704965?s=20&t=TA5bW8K-wxczoaW2Q6UWCQ*\n\nAs noted above `rename()` takes its inputs following the usual tidyverse-style, \nmeaning `rename(newname = oldname)`. This can be translated to the situation at \nhand by using the corresponding columns from the spreadsheet to create a named \nvector that has the information newname as 'name' and oldname as value. `tibble::deframe()` \nis suitable for this situation as described in the help-page: \n > deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value.\n\n**For T0**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a named vector\nhelper_rename_t0 <- name_tbl %>%\n  select(global, T0) %>% # take the two variables needed\n  drop_na() %>% # drop_na() is important here \n  deframe() # deframe creates the named vector\n\n# rename with !!! \n(global_t0 <- \n  orig_t0 %>%\n    rename(!!!helper_rename_t0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  ID    X1       X2\n  <chr> <chr> <dbl>\n1 A     m         1\n2 B     x         2\n```\n:::\n:::\n\n\n**For T1**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a named vector\nhelper_rename_t1 <- name_tbl %>%\n  select(global, T1) %>% # take the two variables needed\n  drop_na() %>% # drop_na() is important here \n  deframe() # deframe creates the named vector\n\n# rename with !!! \n(global_t1 <- \n  orig_t1 %>%\n    rename(!!!helper_rename_t1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  ID    X1       X2    X3\n  <chr> <chr> <dbl> <dbl>\n1 AAA   f         1    44\n2 BBB   x         2    56\n```\n:::\n:::\n\n\n**For T2**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a named vector\nhelper_rename_t2 <- name_tbl %>%\n  select(global, T2) %>% # take the two variables needed\n  drop_na() %>% # drop_na() is important here \n  deframe() # deframe creates the named vector\n\n# rename with !!! \n(global_t2 <- \n  orig_t2 %>%\n    rename(!!!helper_rename_t2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  ID    X1       X2    X3\n  <chr> <chr> <dbl> <dbl>\n1 FFF   f         2    53\n2 BGG   f         1    23\n```\n:::\n:::\n\n\n**Finally, using `bind_rows()` to combine all datasets**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(version1 <- bind_rows(global_t0, global_t1, global_t2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  ID    X1       X2    X3\n  <chr> <chr> <dbl> <dbl>\n1 A     m         1    NA\n2 B     x         2    NA\n3 AAA   f         1    44\n4 BBB   x         2    56\n5 FFF   f         2    53\n6 BGG   f         1    23\n```\n:::\n:::\n\n\n\nThis approach worked very well, however some elements are repeated for every dataset \n(creating the helper vector, renaming), thus maybe a more functional programming \napproach might be suitable.\n\n### Using functional programming to rename all dataframes at once\n\nThe approach above works very well, yet sometimes its nice to have the output \nchecked to the original content as well (see if the renaming was really correct).\n\nThe code presented here war written with help from the R4DS-online community, \nspecifically [Tyler Smith](https://github.com/TylerGrantSmith]) for the first option and\n[@jonthegeek](https://twitter.com/jonthegeek) for the 2nd one. \n\n**First option**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a long df with matching variable names\nvar_names <- \n  name_tbl %>% \n  rename(to = global) %>% \n  pivot_longer(-to, names_to = \"source\", values_to = \"from\") %>% \n  select(source, from, to) %>% \n  drop_na()\n\n\n# helper function to rename the cols\nrename_cols <- function(.data, from, to) {\n  dplyr::rename(.data, \n                !!!rlang::syms(\n                  purrr::discard(\n                    rlang::set_names(from, to), is.na(from))))\n}\n\n\n# helper function to table the cols\n# to compare their content\ntable_cols <- function(.data, cols, ...) {\n  purrr::map(cols, ~ base::table(.data[[.x]]), ...)\n}\n\n\n# creating a list of all dataframes that need to be renamed\ndata_list <- list(\n  T0 = orig_t0,\n  T1 = orig_t1,\n  T2 = orig_t2\n)\n\n# Create a nested tibble, define the variables to \n# be rename for each row, apply the renaming, finbally validate the\n# data_table (original dataframe) versus the output_table (renamed dataframe)\n\nmapped_object <- \n  enframe(data_list, name = \"source\", value = \"data\") %>%\n  mutate(mapping = map(source, ~ filter(var_names, source == .))) %>%\n  hoist(mapping, from = \"from\", to = \"to\") %>%\n  mutate(\n    output = pmap(list(data, from, to), rename_cols), # renaming\n    data_table = map2(data, from, table_cols, useNA = \"always\"), # validation\n    output_table = map2(output, to, table_cols, useNA = \"always\"), # validation\n    validate = map2_lgl(data_table, output_table, identical) # validation\n  )\n\n\n# from the mapped_pbject, \n# unnest the output - don't forget to store it into its own object\nmapped_object %>% \n  select(output) %>% \n  unnest(cols = output)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  ID    X1       X2    X3\n  <chr> <chr> <dbl> <dbl>\n1 A     m         1    NA\n2 B     x         2    NA\n3 AAA   f         1    44\n4 BBB   x         2    56\n5 FFF   f         2    53\n6 BGG   f         1    23\n```\n:::\n:::\n\n\n**Second option**\n\nThe approach is very similar: use `purrr::map2_dfr()` to indicate the use \nof two lists (.x and .y) whereas .x is the list of the dataframes and .y is the \nlist of the vectors with the names. The suffix `_dfr()` does `bind_rows()` to \ncombine the results into one dataframe\n\n::: {.cell}\n\n```{.r .cell-code}\n# rename \nmap2_dfr(\n  list(orig_t0, orig_t1, orig_t2),\n  list(name_tbl$T0, name_tbl$T1, name_tbl$T2), function(tdf, names) {\n    real_names <- name_tbl$global[!is.na(names)]\n    names <- keep(names, function(v) !is.na(v))\n    tdf %>%\n      rename(!!!rlang::syms(set_names(names, real_names)))\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  ID    X1       X2    X3\n  <chr> <chr> <dbl> <dbl>\n1 A     m         1    NA\n2 B     x         2    NA\n3 AAA   f         1    44\n4 BBB   x         2    56\n5 FFF   f         2    53\n6 BGG   f         1    23\n```\n:::\n:::\n\n\n\n\n### TL;DR\n\n- There are many different options on to how to rename a variable \n\n- This post should give an overview of some of the possibilities I have worked with \n\n- IMHO the best solution depends on the situation at hand - choose your pick!  \n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}